###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       17/Mar/2021  17:48:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Zh\Cortex\soft\mn353_mdr\MN353\src\console.c
#    Command line =  
#        E:\Zh\Cortex\soft\mn353_mdr\MN353\src\console.c -D USE_MDR1986VE9x
#        -lCN E:\Zh\Cortex\soft\mn353_mdr\Debug\List -lb
#        E:\Zh\Cortex\soft\mn353_mdr\Debug\List -o
#        E:\Zh\Cortex\soft\mn353_mdr\Debug\Obj --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zh\Cortex\soft\mn353_mdr\FreeRTOS\src\include\ -I
#        E:\Zh\Cortex\soft\mn353_mdr\MDR_Library\inc\ -I
#        E:\Zh\Cortex\soft\mn353_mdr\startup\ -I
#        E:\Zh\Cortex\soft\mn353_mdr\mn353\inc\ -Ol --use_c++_inline
#    Locale       =  Russian_Russia.1251
#    List file    =  E:\Zh\Cortex\soft\mn353_mdr\Debug\List\console.lst
#    Object file  =  E:\Zh\Cortex\soft\mn353_mdr\Debug\Obj\console.o
#
###############################################################################

E:\Zh\Cortex\soft\mn353_mdr\MN353\src\console.c
      1          
      2          #include <MDR32Fx.h>

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0940             LSRS     R0,R0,#+5
   \   00000010   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
      3          #include <types.h>
      4          #include <string.h>
      5          #include <stdarg.h>
      6          #include <stddef.h>
      7          #include <stddef.h>
      8          #include <ctype.h>
      9          #include <limits.h>
     10          
     11          #include "MDR32F9Qx_uart.h"
     12          #include "MDR32F9Qx_rst_clk.h"
     13          #include "MDR32F9Qx_port.h"
     14          #include "serial.h"
     15          

   \                                 In section .bss, align 1
     16          static u8 dbg_print_mode = 0; // 0x00  -  штатная работа;
   \                     dbg_print_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     17          static MDR_UART_TypeDef *CON_UART;
   \                     CON_UART:
   \   00000000                      DS8 4
     18          

   \                                 In section .bss, align 4
     19          static SERIAL_LINE console;
   \                     console:
   \   00000000                      DS8 524
     20          

   \                                 In section .bss, align 4
     21          int rxirq_count;
   \                     rxirq_count:
   \   00000000                      DS8 4
     22          
     23          //------------------------------------------------------------------------------
     24          // Обработчик прерывания "приёмник полон"
     25          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     26          static inline void irq_rx( u8 byte )
     27          {
     28            rxirq_count++; // Это чтоб посмотреть протребление в режиме sleep
   \                     irq_rx: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000000C   0x6011             STR      R1,[R2, #+0]
     29            
     30              // Сохранить байт в циклическом буфере, из которого можно считать
     31              // с помощью функции getch()
     32              u8 e = (console.rx.e + 1) & (RX_SIZE-1);
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000012   0xF891 0x1105      LDRB     R1,[R1, #+261]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
     33              if (e == console.rx.b) 
   \   00000018   0x000A             MOVS     R2,R1
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable13_3
   \   0000001E   0xF893 0x3104      LDRB     R3,[R3, #+260]
   \   00000022   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000024   0x429A             CMP      R2,R3
   \   00000026   0xD00C             BEQ.N    ??irq_rx_0
     34                  return;    // Переполнение входного буфера
     35              console.rx.buf[console.rx.e] = byte;
   \                     ??irq_rx_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable13_3
   \   00000030   0xF893 0x3105      LDRB     R3,[R3, #+261]
   \   00000034   0x441A             ADD      R2,R2,R3
   \   00000036   0xF882 0x0106      STRB     R0,[R2, #+262]
     36              console.rx.e = e;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000003E   0xF880 0x1105      STRB     R1,[R0, #+261]
     37          }
   \                     ??irq_rx_0: (+1)
   \   00000042   0x4770             BX       LR               ;; return
     38          
     39          //------------------------------------------------------------------------------
     40          // Обработчик прерывания "передатчик пуст"
     41          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     42          static inline int irq_tx()
     43          {
     44              u8 byte;
     45              u16 b = console.tx.beg;
   \                     irq_tx: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
     46              if ( b == console.tx.end ) return -1;
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   0000000C   0x8852             LDRH     R2,[R2, #+2]
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x4290             CMP      R0,R2
   \   00000012   0xD102             BNE.N    ??irq_tx_0
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0xE00B             B.N      ??irq_tx_1
     47              byte = console.tx.buf[b];
   \                     ??irq_tx_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x4408             ADD      R0,R0,R1
   \   00000022   0x7900             LDRB     R0,[R0, #+4]
     48              console.tx.beg = (b + 1)&(TX_SIZE-1);
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \   00000026   0xF001 0x01FF      AND      R1,R1,#0xFF
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   0000002E   0x8011             STRH     R1,[R2, #+0]
     49              return byte;
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??irq_tx_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
     50          }
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void CON_UART_HandlerWork(void)
     53          {
   \                     CON_UART_HandlerWork: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xE006             B.N      ??CON_UART_HandlerWork_0
     54              u32 SR;
     55              while(1) {
     56                  SR = CON_UART->MIS;
     57                  
     58                  if (SR == 0) 
     59                      // Всё обработано
     60                      break;
     61                  if ( SR & UART_MIS_RXMIS)
     62                      // Обработать принятый байт
     63                      irq_rx(CON_UART->DR);
     64                  if ( SR & UART_MIS_TXMIS ) {
     65                      int byte;
     66                      byte = irq_tx(); // Есть чего передавать? 
     67                      if ( byte < 0 ) 
     68                          // Нет - запретить прерывания по передаче
     69                          UART_ITConfig(CON_UART,UART_IT_TX,DISABLE);
   \                     ??CON_UART_HandlerWork_1: (+1)
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       UART_ITConfig
   \                     ??CON_UART_HandlerWork_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6C04             LDR      R4,[R0, #+64]
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD100             BNE.N    ??CON_UART_HandlerWork_2
     70                      else 
     71                          // Да - передать
     72                          CON_UART->DR = (u8)byte;
     73                  }
     74              }
     75          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??CON_UART_HandlerWork_2: (+1)
   \   00000020   0x06E0             LSLS     R0,R4,#+27
   \   00000022   0xD506             BPL.N    ??CON_UART_HandlerWork_3
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       irq_rx
   \                     ??CON_UART_HandlerWork_3: (+1)
   \   00000032   0x06A0             LSLS     R0,R4,#+26
   \   00000034   0xD5ED             BPL.N    ??CON_UART_HandlerWork_0
   \   00000036   0x.... 0x....      BL       irq_tx
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD4E2             BMI.N    ??CON_UART_HandlerWork_1
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x6008             STR      R0,[R1, #+0]
   \   00000048   0xE7E3             B.N      ??CON_UART_HandlerWork_0
     76          /*
     77          void UART2_IRQHandler(void)
     78          {
     79            CON_UART_HandlerWork();
     80          }
     81          */

   \                                 In section .text, align 2, keep-with-next
     82          void UART1_IRQHandler(void)
     83          {
   \                     UART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     84            CON_UART_HandlerWork();
   \   00000002   0x.... 0x....      BL       CON_UART_HandlerWork
     85          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
     86          
     87          
     88          //------------------------------------------------------------------------------
     89          // Извлечь байт из буфера клавиатуры.
     90          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     91          int getch()
     92          {
     93              u8 byte;
     94          
     95              if (console.rx.b == console.rx.e) {
   \                     getch: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000004   0xF890 0x0104      LDRB     R0,[R0, #+260]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000000C   0xF891 0x1105      LDRB     R1,[R1, #+261]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD102             BNE.N    ??getch_0
     96          	//Dispatch(1);
     97          	return -1;
   \   00000014   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000018   0xE012             B.N      ??getch_1
     98              }
     99              byte = console.rx.buf[console.rx.b];
   \                     ??getch_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000022   0xF891 0x1104      LDRB     R1,[R1, #+260]
   \   00000026   0x4408             ADD      R0,R0,R1
   \   00000028   0xF890 0x0106      LDRB     R0,[R0, #+262]
    100              console.rx.b = (console.rx.b + 1) & (RX_SIZE-1);
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000030   0xF891 0x1104      LDRB     R1,[R1, #+260]
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   0000003A   0xF882 0x1104      STRB     R1,[R2, #+260]
    101              return byte;
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??getch_1: (+1)
   \   00000040   0x4770             BX       LR               ;; return
    102          }
    103          
    104          //------------------------------------------------------------------------------
    105          // Очистить буфер клавиатуры.
    106          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    107          void console_clear_con()
    108          {
    109              __disable_interrupt();
   \                     console_clear_con: (+1)
   \   00000000   0xB672             CPSID    I
    110              console.rx.b = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000008   0xF881 0x0104      STRB     R0,[R1, #+260]
    111              console.rx.e = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000012   0xF881 0x0105      STRB     R0,[R1, #+261]
    112              __enable_interrupt();
   \   00000016   0xB662             CPSIE    I
    113          }
   \   00000018   0x4770             BX       LR               ;; return
    114          
    115          //------------------------------------------------------------------------------
    116          // Получить текущую частоту CPU_CLK
    117          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    118          u32 RST_CLK_GetCpuClock(void)
    119          {
    120            u32 cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
    121            u32 pll_mul;
    122            u32 temp;
    123          
    124          
    125              // Determine CPU_C1 frequency
    126              cpu_c1_freq = (u32)8000000;
   \                     RST_CLK_GetCpuClock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x7a1200
    127              if (MDR_RST_CLK->CPU_CLOCK & 1) {
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x4002000c
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x07C9             LSLS     R1,R1,#+31
   \   0000000C   0xD500             BPL.N    ??RST_CLK_GetCpuClock_0
    128                cpu_c1_freq /= 2;
   \   0000000E   0x0840             LSRS     R0,R0,#+1
    129              }
    130          
    131              // Determine CPU_C2 frequency 
    132              cpu_c2_freq = cpu_c1_freq;
    133              
    134              if  (MDR_RST_CLK->CPU_CLOCK & 4) {
   \                     ??RST_CLK_GetCpuClock_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x4002000c
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x0749             LSLS     R1,R1,#+29
   \   00000018   0xD506             BPL.N    ??RST_CLK_GetCpuClock_1
    135                // Determine CPU PLL output frequency
    136                pll_mul = ((MDR_RST_CLK->PLL_CONTROL >> 8) & (u32)0x0F) + 1;
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable13_7  ;; 0x40020004
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0xF3C1 0x2103      UBFX     R1,R1,#+8,#+4
   \   00000024   0x1C49             ADDS     R1,R1,#+1
    137                cpu_c2_freq *= pll_mul;
   \   00000026   0x4348             MULS     R0,R1,R0
    138              }
    139          
    140              // Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases 
    141              switch ((MDR_RST_CLK->CPU_CLOCK >> 8) & (u32)0x03) {
   \                     ??RST_CLK_GetCpuClock_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x4002000c
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x0A09             LSRS     R1,R1,#+8
   \   00000030   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD003             BEQ.N    ??RST_CLK_GetCpuClock_2
   \   00000038   0x2902             CMP      R1,#+2
   \   0000003A   0xD015             BEQ.N    ??RST_CLK_GetCpuClock_3
   \   0000003C   0xD303             BCC.N    ??RST_CLK_GetCpuClock_4
   \   0000003E   0xE016             B.N      ??RST_CLK_GetCpuClock_5
    142              case 0 : // HSI
    143                  temp = (u32)8000000;
   \                     ??RST_CLK_GetCpuClock_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x7a1200
    144                  break;
   \   00000044   0xE015             B.N      ??RST_CLK_GetCpuClock_6
    145              case 1 : // CPU_C3
    146                  // Determine CPU_C3 frequency 
    147                  if ((MDR_RST_CLK->CPU_CLOCK >> 4 & (u32)0x08) == 0x00) {
   \                     ??RST_CLK_GetCpuClock_4: (+1)
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x4002000c
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x0909             LSRS     R1,R1,#+4
   \   0000004E   0x0709             LSLS     R1,R1,#+28
   \   00000050   0xD509             BPL.N    ??RST_CLK_GetCpuClock_7
    148                      cpu_c3_freq = cpu_c2_freq;
    149                  }
    150                  else {
    151                      cpu_c3_freq = cpu_c2_freq/
    152                                    (1 << ((MDR_RST_CLK->CPU_CLOCK >> 4 & (u32)0x07) + 1));
   \                     ??RST_CLK_GetCpuClock_8: (+1)
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable13_6  ;; 0x4002000c
   \   00000058   0x6812             LDR      R2,[R2, #+0]
   \   0000005A   0xF3C2 0x1202      UBFX     R2,R2,#+4,#+3
   \   0000005E   0x1C52             ADDS     R2,R2,#+1
   \   00000060   0x4091             LSLS     R1,R1,R2
   \   00000062   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    153                  }
    154                  temp = cpu_c3_freq;
    155                  break;
   \                     ??RST_CLK_GetCpuClock_7: (+1)
   \   00000066   0xE004             B.N      ??RST_CLK_GetCpuClock_6
    156              case 2 : // LSE 
    157                  temp = (u32)32768;
   \                     ??RST_CLK_GetCpuClock_3: (+1)
   \   00000068   0xF44F 0x4000      MOV      R0,#+32768
    158                  break;
   \   0000006C   0xE001             B.N      ??RST_CLK_GetCpuClock_6
    159              default : // LSI 
    160                  temp = (u32)40000;
   \                     ??RST_CLK_GetCpuClock_5: (+1)
   \   0000006E   0xF649 0x4040      MOVW     R0,#+40000
    161                  break;
    162              }
    163              return temp;
   \                     ??RST_CLK_GetCpuClock_6: (+1)
   \   00000072   0x4770             BX       LR               ;; return
    164          }
    165          
    166          //------------------------------------------------------------------------------
    167          // Инициализация консоли
    168          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    169          void console_init(MDR_UART_TypeDef *UARTx)
    170          {    
   \                     console_init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
    171              //u32 tmpreg;
    172              UART_InitTypeDef UART_InitStruct;
    173              PORT_InitTypeDef PORT_InitStruct;
    174               
    175              CON_UART = UARTx;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   0000000A   0x6004             STR      R4,[R0, #+0]
    176              memset( &console, 0, sizeof(console) );	 // Инициализация структуры
   \   0000000C   0xF44F 0x7103      MOV      R1,#+524
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable13_3
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       __aeabi_memset
    177              
    178              // Разрешить тактирование UART
    179              if (UARTx == MDR_UART1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40030000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD104             BNE.N    ??console_init_0
    180                  RST_CLK_PCLKcmd(RST_CLK_PCLK_UART1, ENABLE);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x.... 0x....      BL       RST_CLK_PCLKcmd
   \   0000002C   0xE003             B.N      ??console_init_1
    181              else
    182                  RST_CLK_PCLKcmd(RST_CLK_PCLK_UART2, ENABLE);
   \                     ??console_init_0: (+1)
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x2080             MOVS     R0,#+128
   \   00000032   0x.... 0x....      BL       RST_CLK_PCLKcmd
    183              UART_BRGInit(UARTx, UART_HCLKdiv1);      // Установит частоту HCLK
   \                     ??console_init_1: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_BRGInit
    184              
    185              // Настроить UART
    186              UART_InitStruct.UART_BaudRate   = CONSOLE_SPEED;
   \   0000003E   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000042   0x9003             STR      R0,[SP, #+12]
    187              UART_InitStruct.UART_WordLength = UART_WordLength8b;
   \   00000044   0x2060             MOVS     R0,#+96
   \   00000046   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    188              UART_InitStruct.UART_StopBits   = UART_StopBits1;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    189              UART_InitStruct.UART_Parity     = UART_Parity_No;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    190              UART_InitStruct.UART_FIFOMode   = UART_FIFO_OFF;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    191              UART_InitStruct.UART_HardwareFlowControl = 
    192                            UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;    
   \   0000005C   0xF44F 0x7040      MOV      R0,#+768
   \   00000060   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    193              UART_Init(UARTx,&UART_InitStruct);        
   \   00000064   0xA903             ADD      R1,SP,#+12
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       UART_Init
    194          
    195              // Подключить UART к ножкам
    196              // UART1 штатная консоль для МН353 взамен МН352, на LDM-K1986BE92QI можно 
    197              // перемычками вывести с XS9 на XS7 PB[5,6]
    198              if (UARTx == MDR_UART1) {
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40030000
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD106             BNE.N    ??console_init_2
    199                  PORT_InitStruct.PORT_Pin   = PORT_Pin_5 | PORT_Pin_6;
   \   00000074   0x2060             MOVS     R0,#+96
   \   00000076   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    200                  PORT_InitStruct.PORT_FUNC  = PORT_FUNC_ALTER;
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000080   0xE005             B.N      ??console_init_3
    201              }
    202              else {
    203                  PORT_InitStruct.PORT_Pin   = PORT_Pin_0 | PORT_Pin_1;
   \                     ??console_init_2: (+1)
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    204                  PORT_InitStruct.PORT_FUNC  = PORT_FUNC_OVERRID;
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    205              }
    206              PORT_InitStruct.PORT_SPEED = PORT_SPEED_SLOW;
   \                     ??console_init_3: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xF88D 0x0009      STRB     R0,[SP, #+9]
    207              PORT_InitStruct.PORT_OE    = PORT_OE_IN;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xF88D 0x0002      STRB     R0,[SP, #+2]
    208              PORT_InitStruct.PORT_MODE  = PORT_MODE_DIGITAL;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xF88D 0x000A      STRB     R0,[SP, #+10]
    209              PORT_InitStruct.PORT_GFEN  = PORT_GFEN_ON;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xF88D 0x0007      STRB     R0,[SP, #+7]
    210              PORT_InitStruct.PORT_PD    = PORT_PD_DRIVER;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF88D 0x0006      STRB     R0,[SP, #+6]
    211              PORT_InitStruct.PORT_PD_SHM = PORT_PD_SHM_OFF;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF88D 0x0005      STRB     R0,[SP, #+5]
    212              PORT_InitStruct.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF88D 0x0004      STRB     R0,[SP, #+4]
    213              PORT_InitStruct.PORT_PULL_UP = PORT_PULL_UP_ON;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF88D 0x0003      STRB     R0,[SP, #+3]
    214              
    215              if (UARTx == MDR_UART1)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40030000
   \   000000C2   0x4284             CMP      R4,R0
   \   000000C4   0xD105             BNE.N    ??console_init_4
    216                  PORT_Init(MDR_PORTB, &PORT_InitStruct);        
   \   000000C6   0x4669             MOV      R1,SP
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable13_9  ;; 0x400b0000
   \   000000CC   0x.... 0x....      BL       PORT_Init
   \   000000D0   0xE004             B.N      ??console_init_5
    217              else
    218                  PORT_Init(MDR_PORTF, &PORT_InitStruct);        
   \                     ??console_init_4: (+1)
   \   000000D2   0x4669             MOV      R1,SP
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable13_10  ;; 0x400e8000
   \   000000D8   0x.... 0x....      BL       PORT_Init
    219          
    220              UART_Cmd(UARTx, ENABLE);                   // Запустить
   \                     ??console_init_5: (+1)
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x0020             MOVS     R0,R4
   \   000000E0   0x.... 0x....      BL       UART_Cmd
    221              UART_ITConfig(UARTx,UART_IT_RX,ENABLE);    // Разрешить прерывания по приему
   \   000000E4   0x2201             MOVS     R2,#+1
   \   000000E6   0x2110             MOVS     R1,#+16
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x.... 0x....      BL       UART_ITConfig
    222              // Размаскировать NVIC 
    223              if (UARTx == MDR_UART1) {
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40030000
   \   000000F2   0x4284             CMP      R4,R0
   \   000000F4   0xD106             BNE.N    ??console_init_6
    224                  NVIC_DisableIRQ(UART2_IRQn);
   \   000000F6   0x2007             MOVS     R0,#+7
   \   000000F8   0x.... 0x....      BL       NVIC_DisableIRQ
    225                  NVIC_EnableIRQ(UART1_IRQn);
   \   000000FC   0x2006             MOVS     R0,#+6
   \   000000FE   0x.... 0x....      BL       NVIC_EnableIRQ
   \   00000102   0xE005             B.N      ??console_init_7
    226              }
    227              else {
    228                  NVIC_DisableIRQ(UART1_IRQn);
   \                     ??console_init_6: (+1)
   \   00000104   0x2006             MOVS     R0,#+6
   \   00000106   0x.... 0x....      BL       NVIC_DisableIRQ
    229                  NVIC_EnableIRQ(UART2_IRQn);
   \   0000010A   0x2007             MOVS     R0,#+7
   \   0000010C   0x.... 0x....      BL       NVIC_EnableIRQ
    230              }
    231          }
   \                     ??console_init_7: (+1)
   \   00000110   0xB007             ADD      SP,SP,#+28
   \   00000112   0xBD30             POP      {R4,R5,PC}       ;; return
    232          
    233          
    234          //------------------------------------------------------------------------------
    235          // Запись байта в циклический буфер передатчика
    236          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    237          void putk(int byte)
    238          {
   \                     putk: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    239              if (dbg_print_mode == 0) {
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable13_11
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD13A             BNE.N    ??putk_0
    240          	u32 t;
    241                  u8 bt;
    242          	
    243          	if (byte == 0) return;
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD04D             BEQ.N    ??putk_1
    244          	
    245          	do	
    246          	    t = (console.tx.end + 1) & (TX_SIZE-1);
   \                     ??putk_2: (+1)
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000014   0x8849             LDRH     R1,[R1, #+2]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0xF001 0x01FF      AND      R1,R1,#0xFF
    247          	while (t == console.tx.beg);			// Ждать свободного места
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   00000020   0x8812             LDRH     R2,[R2, #+0]
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD0F4             BEQ.N    ??putk_2
    248          		
    249                  console.tx.buf[ console.tx.end ] = (u8)byte;	// Поместить байт в буфер
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable13_3
   \   0000002E   0x8852             LDRH     R2,[R2, #+2]
   \   00000030   0x4411             ADD      R1,R1,R2
   \   00000032   0x7108             STRB     R0,[R1, #+4]
    250                  console.tx.end = (console.tx.end + 1) & (TX_SIZE-1);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000038   0x8840             LDRH     R0,[R0, #+2]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000044   0x8048             STRH     R0,[R1, #+2]
    251          	  
    252                  if ((CON_UART->IMSC & UART_IMSC_TXIM) == 0) {  
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6B80             LDR      R0,[R0, #+56]
   \   0000004E   0x0680             LSLS     R0,R0,#+26
   \   00000050   0xD42C             BMI.N    ??putk_3
    253                      u16 b = console.tx.beg;
   \   00000052   0x....             LDR.N    R0,??DataTable13_3
   \   00000054   0x8801             LDRH     R1,[R0, #+0]
    254                      bt = console.tx.buf[b];
   \   00000056   0x....             LDR.N    R0,??DataTable13_3
   \   00000058   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0x4408             ADD      R0,R0,R1
   \   0000005C   0x7900             LDRB     R0,[R0, #+4]
    255                      console.tx.beg = (b + 1)&(TX_SIZE-1);
   \   0000005E   0x1C49             ADDS     R1,R1,#+1
   \   00000060   0xF001 0x01FF      AND      R1,R1,#0xFF
   \   00000064   0x....             LDR.N    R2,??DataTable13_3
   \   00000066   0x8011             STRH     R1,[R2, #+0]
    256                      CON_UART->DR = bt;
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x....             LDR.N    R1,??DataTable13_4
   \   0000006C   0x6809             LDR      R1,[R1, #+0]
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    257                      CON_UART->IMSC |= UART_IMSC_TXIM;      	// Разрешить прерывания	
   \   00000070   0x....             LDR.N    R0,??DataTable13_4
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x6B80             LDR      R0,[R0, #+56]
   \   00000076   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007A   0x....             LDR.N    R1,??DataTable13_4
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x6388             STR      R0,[R1, #+56]
   \   00000080   0xE014             B.N      ??putk_3
    258                  }
    259              }
    260              else {			
    261                  // Работаем по опросу (не по прерыванию)
    262          	if (byte == 0) {	
   \                     ??putk_0: (+1)
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD105             BNE.N    ??putk_4
    263                      // Дождаться окончания передачи и выйти
    264                      while ((CON_UART->FR & UART_FR_TXFE) == 0);
   \                     ??putk_5: (+1)
   \   00000086   0x....             LDR.N    R0,??DataTable13_4
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x6980             LDR      R0,[R0, #+24]
   \   0000008C   0x0600             LSLS     R0,R0,#+24
   \   0000008E   0xD5FA             BPL.N    ??putk_5
    265          	    return;
   \   00000090   0xE00C             B.N      ??putk_1
    266          	}
    267                  // Дождаться опустошения буфера и записать в него байт
    268                  while (CON_UART->FR & UART_FR_TXFF);
   \                     ??putk_4: (+1)
   \   00000092   0x....             LDR.N    R1,??DataTable13_4
   \   00000094   0x6809             LDR      R1,[R1, #+0]
   \   00000096   0x6989             LDR      R1,[R1, #+24]
   \   00000098   0x0689             LSLS     R1,R1,#+26
   \   0000009A   0xD4FA             BMI.N    ??putk_4
    269                  CON_UART->DR = byte;
   \   0000009C   0x....             LDR.N    R1,??DataTable13_4
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    270                  if (byte == '\n') putk('\r');
   \   000000A2   0x280A             CMP      R0,#+10
   \   000000A4   0xD102             BNE.N    ??putk_3
   \   000000A6   0x200D             MOVS     R0,#+13
   \   000000A8   0xF7FF 0xFFAA      BL       putk
    271              }
    272          }
   \                     ??putk_3: (+1)
   \                     ??putk_1: (+1)
   \   000000AC   0xBD01             POP      {R0,PC}          ;; return
    273          
    274          //------------------------------------------------------------------------------
    275          // Вывод данных с преобразованием формата
    276          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    277          int printf(const char *fmt, ...)
    278          {
   \                     printf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000006   0x0005             MOVS     R5,R0
    279              int c;
    280              enum { LEFT, RIGHT } adjust;
    281              enum { LONG, INT } intsize;
    282              int fill;
    283              int width, max, len, base;
    284              static const char X2C_tab[]= "0123456789ABCDEF";
    285              static const char x2c_tab[]= "0123456789abcdef";
    286              const char *x2c;
    287              char *p;
    288              long i;
    289              unsigned long u;
    290              char temp[8 * sizeof(long) / 3 + 2];
    291              va_list argp;
    292          
    293              va_start(argp, fmt);
   \   00000008   0xF10D 0x0834      ADD      R8,SP,#+52
   \   0000000C   0xE007             B.N      ??printf_0
    294          
    295              while ((c= *fmt++) != 0) {
    296          	if (c != '%') {
    297          	    // Ordinary character. 
    298          	    putk(c);
   \                     ??printf_1: (+1)
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       putk
    299          	    if (c == '\n') putk('\r');
   \   00000014   0x2C0A             CMP      R4,#+10
   \   00000016   0xD102             BNE.N    ??printf_2
   \   00000018   0x200D             MOVS     R0,#+13
   \   0000001A   0x.... 0x....      BL       putk
    300          	    continue;
    301          	}
   \                     ??printf_2: (+1)
   \                     ??printf_0: (+1)
   \   0000001E   0x782C             LDRB     R4,[R5, #+0]
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD05C             BEQ.N    ??printf_3
   \   00000026   0x2C25             CMP      R4,#+37
   \   00000028   0xD1F1             BNE.N    ??printf_1
    302          	// Format specifier of the form:
    303          	//	%[adjust][fill][width][.max]keys
    304          	//
    305          	c= *fmt++;
   \   0000002A   0x782C             LDRB     R4,[R5, #+0]
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
    306          
    307          	adjust= RIGHT;
   \   0000002E   0x2601             MOVS     R6,#+1
    308          	if (c == '-') {
   \   00000030   0x2C2D             CMP      R4,#+45
   \   00000032   0xD102             BNE.N    ??printf_4
    309          	    adjust= LEFT;
   \   00000034   0x2600             MOVS     R6,#+0
    310          	    c= *fmt++;
   \   00000036   0x782C             LDRB     R4,[R5, #+0]
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
    311          	}
    312          	
    313          	fill= ' ';
   \                     ??printf_4: (+1)
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    314          	if (c == '0') {
   \   0000003E   0x2C30             CMP      R4,#+48
   \   00000040   0xD103             BNE.N    ??printf_5
    315          	    fill= '0';
   \   00000042   0x2030             MOVS     R0,#+48
   \   00000044   0x9000             STR      R0,[SP, #+0]
    316          	    c= *fmt++;
   \   00000046   0x782C             LDRB     R4,[R5, #+0]
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
    317          	}
    318          
    319          	width= 0;
   \                     ??printf_5: (+1)
   \   0000004A   0x2700             MOVS     R7,#+0
    320          	if (c == '*') {
   \   0000004C   0x2C2A             CMP      R4,#+42
   \   0000004E   0xD106             BNE.N    ??printf_6
    321          	    // Width is specified as an argument, e.g. %*d. 
    322          	    width= va_arg(argp, int);
   \   00000050   0xF8D8 0x7000      LDR      R7,[R8, #+0]
   \   00000054   0xF118 0x0804      ADDS     R8,R8,#+4
    323          	    c= *fmt++;
   \   00000058   0x782C             LDRB     R4,[R5, #+0]
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \   0000005C   0xE010             B.N      ??printf_7
    324          	} else
    325          	    if (isdigit(c)) {
   \                     ??printf_6: (+1)
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       isdigit
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD00B             BEQ.N    ??printf_7
    326          		// A number tells the width, e.g. %10d. 
    327          		do {
    328          		    width= width * 10 + (c - '0');
   \                     ??printf_8: (+1)
   \   00000068   0x200A             MOVS     R0,#+10
   \   0000006A   0xFB00 0x4007      MLA      R0,R0,R7,R4
   \   0000006E   0xF1B0 0x0730      SUBS     R7,R0,#+48
    329          		} while (isdigit(c= *fmt++));
   \   00000072   0x7828             LDRB     R0,[R5, #+0]
   \   00000074   0x1C6D             ADDS     R5,R5,#+1
   \   00000076   0x0004             MOVS     R4,R0
   \   00000078   0x.... 0x....      BL       isdigit
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD1F3             BNE.N    ??printf_8
    330          	    }
    331          
    332          	max= INT_MAX;
   \                     ??printf_7: (+1)
   \   00000080   0xF07F 0x4A00      MVNS     R10,#-2147483648
    333          	if (c == '.') {
   \   00000084   0x2C2E             CMP      R4,#+46
   \   00000086   0xD11D             BNE.N    ??printf_9
    334          	    // Max field length coming up. 
    335          	    if ((c= *fmt++) == '*') {
   \   00000088   0x782C             LDRB     R4,[R5, #+0]
   \   0000008A   0x1C6D             ADDS     R5,R5,#+1
   \   0000008C   0x2C2A             CMP      R4,#+42
   \   0000008E   0xD106             BNE.N    ??printf_10
    336          		max= va_arg(argp, int);
   \   00000090   0xF8D8 0xA000      LDR      R10,[R8, #+0]
   \   00000094   0xF118 0x0804      ADDS     R8,R8,#+4
    337          		c= *fmt++;
   \   00000098   0x782C             LDRB     R4,[R5, #+0]
   \   0000009A   0x1C6D             ADDS     R5,R5,#+1
   \   0000009C   0xE012             B.N      ??printf_9
    338          	    } else
    339          		if (isdigit(c)) {
   \                     ??printf_10: (+1)
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       isdigit
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD00D             BEQ.N    ??printf_9
    340          		    max= 0;
   \   000000A8   0xF05F 0x0A00      MOVS     R10,#+0
    341          		    do {
    342          			max= max * 10 + (c - '0');
   \                     ??printf_11: (+1)
   \   000000AC   0x200A             MOVS     R0,#+10
   \   000000AE   0xFB00 0x400A      MLA      R0,R0,R10,R4
   \   000000B2   0xF1B0 0x0A30      SUBS     R10,R0,#+48
    343          		    } while (isdigit(c= *fmt++));
   \   000000B6   0x7828             LDRB     R0,[R5, #+0]
   \   000000B8   0x1C6D             ADDS     R5,R5,#+1
   \   000000BA   0x0004             MOVS     R4,R0
   \   000000BC   0x.... 0x....      BL       isdigit
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD1F3             BNE.N    ??printf_11
    344          		}
    345          	}
    346          
    347          	// Set a few flags to the default. 
    348          	x2c= x2c_tab;
   \                     ??printf_9: (+1)
   \   000000C4   0x....             LDR.N    R1,??DataTable13_12
    349          	i= 0;
   \   000000C6   0xF05F 0x0900      MOVS     R9,#+0
    350          	base= 10;
   \   000000CA   0x200A             MOVS     R0,#+10
    351          	intsize= INT;
   \   000000CC   0x2201             MOVS     R2,#+1
    352          	if (c == 'l' || c == 'L') {
   \   000000CE   0x2C6C             CMP      R4,#+108
   \   000000D0   0xD001             BEQ.N    ??printf_12
   \   000000D2   0x2C4C             CMP      R4,#+76
   \   000000D4   0xD102             BNE.N    ??printf_13
    353          	    // "Long" key, e.g. %ld. 
    354          	    intsize= LONG;
   \                     ??printf_12: (+1)
   \   000000D6   0x2200             MOVS     R2,#+0
    355          	    c= *fmt++;
   \   000000D8   0x782C             LDRB     R4,[R5, #+0]
   \   000000DA   0x1C6D             ADDS     R5,R5,#+1
    356          	}
    357          	if (c == 0) break;
   \                     ??printf_13: (+1)
   \   000000DC   0x2C00             CMP      R4,#+0
   \   000000DE   0xD108             BNE.N    ??printf_14
    358          
    359          	switch (c) {
    360          	   		// Decimal. 
    361          	   case 'd':
    362          			i= intsize == LONG ? va_arg(argp, long)
    363          						: va_arg(argp, int);
    364          			u= i < 0 ? -i : i;
    365          			goto int2ascii;
    366          
    367          	   		// Octal. 
    368          	   case 'o':
    369          			base= 010;
    370          			goto getint;
    371          
    372          	   		// Pointer, interpret as %X or %lX. 
    373          	   case 'p':
    374          			if (sizeof(char *) > sizeof(int)) intsize= LONG;
    375          
    376          	   		// Hexadecimal.  %X prints upper case A-F, not %lx. 
    377          	   case 'X':
    378          			x2c= X2C_tab;
    379          	   case 'x':
    380          			base= 0x10;
    381          			goto getint;
    382          
    383          			// Unsigned decimal. 
    384          	   case 'u':
    385          		getint:
    386          			u= intsize == LONG ? va_arg(argp, unsigned long)
    387          						: va_arg(argp, unsigned int);
    388          		int2ascii:
    389          			p= temp + sizeof(temp)-1;
    390          			*p= 0;
    391          			do {
    392          			    *--p= x2c[(ptrdiff_t) (u % base)];
    393          			} while ((u /= base) > 0);
    394          			goto string_length;
    395          
    396          			// A character. 
    397          	   case 'c':
    398          			p= temp;
    399          			*p= va_arg(argp, int);
    400          			len= 1;
    401          			goto string_print;
    402          
    403          			// Simply a percent. 
    404          	   case '%':
    405          			p= temp;
    406          			*p= '%';
    407          			len= 1;
    408          			goto string_print;
    409          
    410          			// A string.  The other cases will join in here. 
    411          	   case 's':
    412          			p= va_arg(argp, char *);
    413          
    414          		string_length:
    415          			for (len= 0; p[len] != 0 && len < max; len++) {}
    416          
    417          		string_print:
    418          			width -= len;
    419          			if (i < 0) width--;
    420          			if (fill == '0' && i < 0) putk('-');
    421          			if (adjust == RIGHT) {
    422          			    while (width > 0) { putk(fill); width--; }
    423          			}
    424          			if (fill == ' ' && i < 0) putk('-');
    425          			while (len > 0) { putk((unsigned char) *p++); len--; }
    426          			while (width > 0) { putk(fill); width--; }
    427          			break;
    428          
    429          			// Unrecognized format key, echo it back. 
    430          	   default:
    431          			putk('%');
    432          			putk(c);
    433          	}
    434              }
    435          
    436              // Mark the end with a null (should be something else, like -1). 
    437              putk(0);
   \                     ??printf_3: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x.... 0x....      BL       putk
    438              va_end(argp);
    439              //while( console.tx.beg != console.tx.end );
    440              return 0;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xB004             ADD      SP,SP,#+16
   \   000000EA   0xE8BD 0x0FF0      POP      {R4-R11}
   \   000000EE   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   \                     ??printf_14: (+1)
   \   000000F2   0x0023             MOVS     R3,R4
   \   000000F4   0x2B25             CMP      R3,#+37
   \   000000F6   0xD04D             BEQ.N    ??printf_15
   \   000000F8   0x2B58             CMP      R3,#+88
   \   000000FA   0xD024             BEQ.N    ??printf_16
   \   000000FC   0x2B63             CMP      R3,#+99
   \   000000FE   0xD040             BEQ.N    ??printf_17
   \   00000100   0x2B64             CMP      R3,#+100
   \   00000102   0xD00A             BEQ.N    ??printf_18
   \   00000104   0x2B6F             CMP      R3,#+111
   \   00000106   0xD01C             BEQ.N    ??printf_19
   \   00000108   0x2B70             CMP      R3,#+112
   \   0000010A   0xD01C             BEQ.N    ??printf_20
   \   0000010C   0x2B73             CMP      R3,#+115
   \   0000010E   0xD047             BEQ.N    ??printf_21
   \   00000110   0x2B75             CMP      R3,#+117
   \   00000112   0xD01A             BEQ.N    ??printf_22
   \   00000114   0x2B78             CMP      R3,#+120
   \   00000116   0xD017             BEQ.N    ??printf_23
   \   00000118   0xE085             B.N      ??printf_24
   \                     ??printf_18: (+1)
   \   0000011A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000011C   0x2A00             CMP      R2,#+0
   \   0000011E   0xD104             BNE.N    ??printf_25
   \   00000120   0xF8D8 0x9000      LDR      R9,[R8, #+0]
   \   00000124   0xF118 0x0804      ADDS     R8,R8,#+4
   \   00000128   0xE003             B.N      ??printf_26
   \                     ??printf_25: (+1)
   \   0000012A   0xF8D8 0x9000      LDR      R9,[R8, #+0]
   \   0000012E   0xF118 0x0804      ADDS     R8,R8,#+4
   \                     ??printf_26: (+1)
   \   00000132   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000136   0xD502             BPL.N    ??printf_27
   \   00000138   0xF1D9 0x0200      RSBS     R2,R9,#+0
   \   0000013C   0xE000             B.N      ??printf_28
   \                     ??printf_27: (+1)
   \   0000013E   0x464A             MOV      R2,R9
   \                     ??printf_28: (+1)
   \   00000140   0xE00F             B.N      ??printf_29
   \                     ??printf_19: (+1)
   \   00000142   0x2008             MOVS     R0,#+8
   \   00000144   0xE001             B.N      ??printf_22
   \                     ??printf_20: (+1)
   \                     ??printf_16: (+1)
   \   00000146   0x....             LDR.N    R1,??DataTable13_13
   \                     ??printf_23: (+1)
   \   00000148   0x2010             MOVS     R0,#+16
   \                     ??printf_22: (+1)
   \   0000014A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000014C   0x2A00             CMP      R2,#+0
   \   0000014E   0xD104             BNE.N    ??printf_30
   \   00000150   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \   00000154   0xF118 0x0804      ADDS     R8,R8,#+4
   \   00000158   0xE003             B.N      ??printf_29
   \                     ??printf_30: (+1)
   \   0000015A   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \   0000015E   0xF118 0x0804      ADDS     R8,R8,#+4
   \                     ??printf_29: (+1)
   \   00000162   0xF10D 0x040F      ADD      R4,SP,#+15
   \   00000166   0x2300             MOVS     R3,#+0
   \   00000168   0x7023             STRB     R3,[R4, #+0]
   \                     ??printf_31: (+1)
   \   0000016A   0x1E64             SUBS     R4,R4,#+1
   \   0000016C   0xFBB2 0xF3F0      UDIV     R3,R2,R0
   \   00000170   0xFB00 0x2313      MLS      R3,R0,R3,R2
   \   00000174   0x5CCB             LDRB     R3,[R1, R3]
   \   00000176   0x7023             STRB     R3,[R4, #+0]
   \   00000178   0xFBB2 0xF2F0      UDIV     R2,R2,R0
   \   0000017C   0x2A00             CMP      R2,#+0
   \   0000017E   0xD1F4             BNE.N    ??printf_31
   \   00000180   0xE012             B.N      ??printf_32
   \                     ??printf_17: (+1)
   \   00000182   0xAC01             ADD      R4,SP,#+4
   \   00000184   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000188   0xF118 0x0804      ADDS     R8,R8,#+4
   \   0000018C   0x7020             STRB     R0,[R4, #+0]
   \   0000018E   0xF05F 0x0B01      MOVS     R11,#+1
   \   00000192   0xE014             B.N      ??printf_33
   \                     ??printf_15: (+1)
   \   00000194   0xAC01             ADD      R4,SP,#+4
   \   00000196   0x2025             MOVS     R0,#+37
   \   00000198   0x7020             STRB     R0,[R4, #+0]
   \   0000019A   0xF05F 0x0B01      MOVS     R11,#+1
   \   0000019E   0xE00E             B.N      ??printf_33
   \                     ??printf_21: (+1)
   \   000001A0   0xF8D8 0x4000      LDR      R4,[R8, #+0]
   \   000001A4   0xF118 0x0804      ADDS     R8,R8,#+4
   \                     ??printf_32: (+1)
   \   000001A8   0xF05F 0x0B00      MOVS     R11,#+0
   \   000001AC   0xE001             B.N      ??printf_34
   \                     ??printf_35: (+1)
   \   000001AE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??printf_34: (+1)
   \   000001B2   0xF814 0x000B      LDRB     R0,[R4, R11]
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD001             BEQ.N    ??printf_33
   \   000001BA   0x45D3             CMP      R11,R10
   \   000001BC   0xDBF7             BLT.N    ??printf_35
   \                     ??printf_33: (+1)
   \   000001BE   0xEBB7 0x070B      SUBS     R7,R7,R11
   \   000001C2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001C6   0xD500             BPL.N    ??printf_36
   \   000001C8   0x1E7F             SUBS     R7,R7,#+1
   \                     ??printf_36: (+1)
   \   000001CA   0x9800             LDR      R0,[SP, #+0]
   \   000001CC   0x2830             CMP      R0,#+48
   \   000001CE   0xD105             BNE.N    ??printf_37
   \   000001D0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001D4   0xD502             BPL.N    ??printf_37
   \   000001D6   0x202D             MOVS     R0,#+45
   \   000001D8   0x.... 0x....      BL       putk
   \                     ??printf_37: (+1)
   \   000001DC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001DE   0x2E01             CMP      R6,#+1
   \   000001E0   0xD106             BNE.N    ??printf_38
   \   000001E2   0xE003             B.N      ??printf_39
   \                     ??printf_40: (+1)
   \   000001E4   0x9800             LDR      R0,[SP, #+0]
   \   000001E6   0x.... 0x....      BL       putk
   \   000001EA   0x1E7F             SUBS     R7,R7,#+1
   \                     ??printf_39: (+1)
   \   000001EC   0x2F01             CMP      R7,#+1
   \   000001EE   0xDAF9             BGE.N    ??printf_40
   \                     ??printf_38: (+1)
   \   000001F0   0x9800             LDR      R0,[SP, #+0]
   \   000001F2   0x2820             CMP      R0,#+32
   \   000001F4   0xD10C             BNE.N    ??printf_41
   \   000001F6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001FA   0xD509             BPL.N    ??printf_41
   \   000001FC   0x202D             MOVS     R0,#+45
   \   000001FE   0x.... 0x....      BL       putk
   \   00000202   0xE005             B.N      ??printf_41
   \                     ??printf_42: (+1)
   \   00000204   0x7820             LDRB     R0,[R4, #+0]
   \   00000206   0x.... 0x....      BL       putk
   \   0000020A   0x1C64             ADDS     R4,R4,#+1
   \   0000020C   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \                     ??printf_41: (+1)
   \   00000210   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000214   0xDAF6             BGE.N    ??printf_42
   \                     ??printf_43: (+1)
   \   00000216   0x2F01             CMP      R7,#+1
   \   00000218   0xDB04             BLT.N    ??printf_44
   \   0000021A   0x9800             LDR      R0,[SP, #+0]
   \   0000021C   0x.... 0x....      BL       putk
   \   00000220   0x1E7F             SUBS     R7,R7,#+1
   \   00000222   0xE7F8             B.N      ??printf_43
   \                     ??printf_44: (+1)
   \   00000224   0xE6FB             B.N      ??printf_0
   \                     ??printf_24: (+1)
   \   00000226   0x2025             MOVS     R0,#+37
   \   00000228   0x.... 0x....      BL       putk
   \   0000022C   0x0020             MOVS     R0,R4
   \   0000022E   0x.... 0x....      BL       putk
   \   00000232   0xE6F4             B.N      ??printf_0
    441          }

   \                                 In section .rodata, align 4
   \                     `printf::X2C_tab`:
   \   00000000   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `printf::x2c_tab`:
   \   00000000   0x30 0x31          DC8 "0123456789abcdef"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    442          

   \                                 In section .text, align 2, keep-with-next
    443          char *GetConsoleName(void) 
    444          {
    445               if (CON_UART == MDR_UART1) return "MDR_UART1";
   \                     GetConsoleName: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable13_8  ;; 0x40030000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD101             BNE.N    ??GetConsoleName_0
   \   0000000A   0x....             LDR.N    R0,??DataTable13_14
   \   0000000C   0xE000             B.N      ??GetConsoleName_1
    446               else return "MDR_UART2";
   \                     ??GetConsoleName_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable13_15
   \                     ??GetConsoleName_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    447          }
    448          

   \                                 In section .text, align 2, keep-with-next
    449          void console_set_poll_mode()
    450          {
   \                     console_set_poll_mode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    451            dbg_print_mode = 0xF;
   \   00000002   0x200F             MOVS     R0,#+15
   \   00000004   0x....             LDR.N    R1,??DataTable13_11
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    452            // запретить прерывания по передаче
    453            UART_ITConfig(CON_UART,UART_IT_TX,DISABLE);
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2120             MOVS     R1,#+32
   \   0000000C   0x....             LDR.N    R0,??DataTable13_4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x.... 0x....      BL       UART_ITConfig
    454          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    455          
    456          extern void hard_reset();

   \                                 In section .text, align 2, keep-with-next
    457          void dbg_put(char c)
    458          {
   \                     dbg_put: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    459            //u8_t byte = c+0x30;
    460            dbg_print_mode = 0xF;
   \   00000004   0x200F             MOVS     R0,#+15
   \   00000006   0x....             LDR.N    R1,??DataTable13_11
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    461            // запретить прерывания по передаче
    462            UART_ITConfig(CON_UART,UART_IT_TX,DISABLE);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x....             LDR.N    R0,??DataTable13_4
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       UART_ITConfig
    463            //CON_UART->IMSC &= ~UART_IT;
    464          
    465            switch(c) {
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2C03             CMP      R4,#+3
   \   0000001A   0xD006             BEQ.N    ??dbg_put_0
   \   0000001C   0xD315             BCC.N    ??dbg_put_1
   \   0000001E   0x2C05             CMP      R4,#+5
   \   00000020   0xD00B             BEQ.N    ??dbg_put_2
   \   00000022   0xD306             BCC.N    ??dbg_put_3
   \   00000024   0x2C06             CMP      R4,#+6
   \   00000026   0xD00C             BEQ.N    ??dbg_put_4
   \   00000028   0xE00F             B.N      ??dbg_put_1
    466            case 3: printf("\r\nHard Fault\r\n"); break;
   \                     ??dbg_put_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable13_16
   \   0000002C   0x.... 0x....      BL       printf
   \   00000030   0xE00E             B.N      ??dbg_put_5
    467            case 4: printf("\r\nMemory Management Fault\r\n"); break;
   \                     ??dbg_put_3: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable13_17
   \   00000034   0x.... 0x....      BL       printf
   \   00000038   0xE00A             B.N      ??dbg_put_5
    468            case 5: printf("\r\nBus Fault\r\n"); break;
   \                     ??dbg_put_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable13_18
   \   0000003C   0x.... 0x....      BL       printf
   \   00000040   0xE006             B.N      ??dbg_put_5
    469            case 6: printf("\r\nUsage Fault\r\n"); break;
   \                     ??dbg_put_4: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable13_19
   \   00000044   0x.... 0x....      BL       printf
   \   00000048   0xE002             B.N      ??dbg_put_5
    470            default: printf("\r\nUnknown Fault\r\n"); break;
   \                     ??dbg_put_1: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable13_20
   \   0000004C   0x.... 0x....      BL       printf
    471            }
    472            /*
    473            // Дождаться опустошения буфера и записать в него байт
    474            while (CON_UART->FR & UART_FR_TXFF);
    475            CON_UART->DR = byte; 
    476            while (CON_UART->FR & UART_FR_TXFF);
    477            CON_UART->DR = byte;
    478            while (CON_UART->FR & UART_FR_TXFF);
    479            */
    480            hard_reset();
   \                     ??dbg_put_5: (+1)
   \   00000050   0x.... 0x....      BL       hard_reset
    481          }
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
    482          
    483          

   \                                 In section .text, align 2, keep-with-next
    484          int getc()
    485          {
   \                     getc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    486              int c;
    487              while ((c=getch()) < 0);
   \                     ??getc_0: (+1)
   \   00000002   0x.... 0x....      BL       getch
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD4FB             BMI.N    ??getc_0
    488              return c;
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    489          }
    490          

   \                                 In section .text, align 2, keep-with-next
    491          char * __gets(char *s, int n) 
    492          {
   \                     __gets: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    493              register int ch;
    494              register char *ptr;
    495              int nn = n;
   \   00000008   0x46A8             MOV      R8,R5
    496          
    497              ptr = s;
   \   0000000A   0x0027             MOVS     R7,R4
   \   0000000C   0xE007             B.N      ??__gets_0
    498          a:    
    499              while (nn > 0 ) {
    500                  ch = getc();
    501                  if (ch == 127) {        // Backspace
    502                      if (nn != n) {
    503                         nn++;
    504                         ptr--;
    505                         putk(ch);
    506                      }
    507                      continue;
    508                  }
    509                  putk(ch);
    510                  if (ch == '\r')
    511                      putk('\n');
    512          	*ptr++ = ch;
    513                  nn--;
    514          	if ((ch == '\n') || (ch == '\r'))
    515          	    break;
    516              }
    517              if ((ch != '\n') && (ch != '\r')) {
    518                  // Дошли до края, ждём Enter или Backspace
    519                  for (;;) {
    520                      ch = getc();
    521                      if ((ch == '\n') || (ch == '\r')) {
    522                          putk('\n');
    523                          putk('\r');
    524                          break;
    525                      }
    526                      if (ch == 127) {        // Backspace
   \                     ??__gets_1: (+1)
   \   0000000E   0x2E7F             CMP      R6,#+127
   \   00000010   0xD12A             BNE.N    ??__gets_2
    527                           nn++;
   \   00000012   0xF118 0x0801      ADDS     R8,R8,#+1
    528                           ptr--;
   \   00000016   0x1E7F             SUBS     R7,R7,#+1
    529                           putk(ch);
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       putk
    530                           goto a;
    531                      }
   \                     ??__gets_0: (+1)
   \   0000001E   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000022   0xDB1D             BLT.N    ??__gets_3
   \   00000024   0x.... 0x....      BL       getc
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x2E7F             CMP      R6,#+127
   \   0000002C   0xD108             BNE.N    ??__gets_4
   \   0000002E   0x45A8             CMP      R8,R5
   \   00000030   0xD005             BEQ.N    ??__gets_5
   \   00000032   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000036   0x1E7F             SUBS     R7,R7,#+1
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       putk
   \                     ??__gets_5: (+1)
   \   0000003E   0xE7EE             B.N      ??__gets_0
   \                     ??__gets_4: (+1)
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       putk
   \   00000046   0x2E0D             CMP      R6,#+13
   \   00000048   0xD102             BNE.N    ??__gets_6
   \   0000004A   0x200A             MOVS     R0,#+10
   \   0000004C   0x.... 0x....      BL       putk
   \                     ??__gets_6: (+1)
   \   00000050   0x703E             STRB     R6,[R7, #+0]
   \   00000052   0x1C7F             ADDS     R7,R7,#+1
   \   00000054   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000058   0x2E0A             CMP      R6,#+10
   \   0000005A   0xD001             BEQ.N    ??__gets_7
   \   0000005C   0x2E0D             CMP      R6,#+13
   \   0000005E   0xD1DE             BNE.N    ??__gets_0
   \                     ??__gets_7: (+1)
   \                     ??__gets_3: (+1)
   \   00000060   0x2E0A             CMP      R6,#+10
   \   00000062   0xD00E             BEQ.N    ??__gets_8
   \   00000064   0x2E0D             CMP      R6,#+13
   \   00000066   0xD00C             BEQ.N    ??__gets_8
   \                     ??__gets_2: (+1)
   \   00000068   0x.... 0x....      BL       getc
   \   0000006C   0x0006             MOVS     R6,R0
   \   0000006E   0x2E0A             CMP      R6,#+10
   \   00000070   0xD001             BEQ.N    ??__gets_9
   \   00000072   0x2E0D             CMP      R6,#+13
   \   00000074   0xD1CB             BNE.N    ??__gets_1
   \                     ??__gets_9: (+1)
   \   00000076   0x200A             MOVS     R0,#+10
   \   00000078   0x.... 0x....      BL       putk
   \   0000007C   0x200D             MOVS     R0,#+13
   \   0000007E   0x.... 0x....      BL       putk
    532                  }
    533              }
    534              *ptr = '\0';
   \                     ??__gets_8: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x7038             STRB     R0,[R7, #+0]
    535              return s;
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    536          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     rxirq_count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     console

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     CON_UART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x4002000C         DC32     0x4002000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40030000         DC32     0x40030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x400B0000         DC32     0x400b0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x400E8000         DC32     0x400e8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     dbg_print_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     `printf::x2c_tab`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x........         DC32     `printf::X2C_tab`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x4D 0x44          DC8 "MDR_UART1"
   \              0x52 0x5F    
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x31 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4D 0x44          DC8 "MDR_UART2"
   \              0x52 0x5F    
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x32 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x0D 0x0A          DC8 "\015\012Hard Fault\015\012"
   \              0x48 0x61    
   \              0x72 0x64    
   \              0x20 0x46    
   \              0x61 0x75    
   \              0x6C 0x74    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x0D 0x0A          DC8 "\015\012Memory Management Fault\015\012"
   \              0x4D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x20 0x4D    
   \              0x61 0x6E    
   \              0x61 0x67    
   \              0x65 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x46 0x61    
   \              0x75 0x6C    
   \              0x74 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x0D 0x0A          DC8 "\015\012Bus Fault\015\012"
   \              0x42 0x75    
   \              0x73 0x20    
   \              0x46 0x61    
   \              0x75 0x6C    
   \              0x74 0x0D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x0D 0x0A          DC8 "\015\012Usage Fault\015\012"
   \              0x55 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x46 0x61    
   \              0x75 0x6C    
   \              0x74 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x0D 0x0A          DC8 "\015\012Unknown Fault\015\012"
   \              0x55 0x6E    
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x46 0x61    
   \              0x75 0x6C    
   \              0x74 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
    537          
    538          
    539          
    540          
    541          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CON_UART_HandlerWork
         8   -> UART_ITConfig
         8   -> irq_rx
         8   -> irq_tx
       0   GetConsoleName
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       0   RST_CLK_GetCpuClock
       8   UART1_IRQHandler
         8   -> CON_UART_HandlerWork
      24   __gets
        24   -> getc
        24   -> putk
       0   console_clear_con
      40   console_init
        40   -> NVIC_DisableIRQ
        40   -> NVIC_EnableIRQ
        40   -> PORT_Init
        40   -> RST_CLK_PCLKcmd
        40   -> UART_BRGInit
        40   -> UART_Cmd
        40   -> UART_ITConfig
        40   -> UART_Init
        40   -> __aeabi_memset
       8   console_set_poll_mode
         8   -> UART_ITConfig
       8   dbg_put
         8   -> UART_ITConfig
         8   -> hard_reset
         8   -> printf
       8   getc
         8   -> getch
       0   getch
       0   irq_rx
       0   irq_tx
      64   printf
        64   -> isdigit
        64   -> putk
       8   putk
         8   -> putk


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      12  ?_0
      12  ?_1
      16  ?_2
      28  ?_3
      16  ?_4
      16  ?_5
      20  ?_6
       4  CON_UART
      74  CON_UART_HandlerWork
      18  GetConsoleName
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
     116  RST_CLK_GetCpuClock
       8  UART1_IRQHandler
      20  X2C_tab
     140  __gets
     524  console
      26  console_clear_con
     276  console_init
      22  console_set_poll_mode
       1  dbg_print_mode
      86  dbg_put
      12  getc
      66  getch
      68  irq_rx
      52  irq_tx
     564  printf
     174  putk
       4  rxirq_count
      20  x2c_tab

 
   533 bytes in section .bss
   160 bytes in section .rodata
 1 830 bytes in section .text
 
 1 830 bytes of CODE  memory
   160 bytes of CONST memory
   533 bytes of DATA  memory

Errors: none
Warnings: none
